# Cs 정렬

## 버블 정렬

- 서로 인접한 두 원소를 검사하여 정렬하는 알고리즘
    - 필요에ㄷ 따라 위치를 교환하면서 정렬하는 알고리즘
    - 시간 복잡도는 최선,평균,최악의 모든 경우 O(n^2)
        
        → 큰 크기의 배열에서는 비효율적일수 있음!
        

![버블정렬.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/79fc6158-622f-41df-b4d6-d39b49b45424/621b0916-c24f-4cad-b7f8-296384def27a/%E1%84%87%E1%85%A5%E1%84%87%E1%85%B3%E1%86%AF%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF.png)

시간 복잡도 

**O(N^2)**

### 동작 방식

1. 배열의 첫번째 원소부터 인접한 원소와 비교
2. 인접한 원소가 순서에 맞지 않는다면 위치 교환
3. 배열의 끝까지 위의 과정을 반복, 가장 큰 원소가 배열의 마지막으로 이동
4. 위의 과정을 배열의 길이만큼 번복! 

### 삽입 정렬

- 이미 정렬된 부분과 비교하여, 자신의 위치를 찾아 삽입하는 방식의 정렬
- 작은 규모의 배열에 대해 효율적인 알고리즘중 하나
![삽입정렬](https://github.com/zzangzzangguy/CS-Study/assets/122965360/4b46a243-1344-4561-8d5f-30687d660ff3)

![삽입정렬.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/79fc6158-622f-41df-b4d6-d39b49b45424/8f6c6a67-87c4-4e2f-9eec-aff761c0da55/%E1%84%89%E1%85%A1%E1%86%B8%E1%84%8B%E1%85%B5%E1%86%B8%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF.png)

### 시간 복잡도

**O(N^2)**

최선,평균,최악 모두 

### 동작 방식

1. 두번째 원소부터 시작, 이전의 정렬된 부분과 비교 올바른 위치에 삽입
2. 선택한 원소를 이전 정렬된 부분의 적절한 위치에 삽입하고, 다른 원소들은 오른쪽으로 한칸씩 읻오
3. 배열의 첫 번째 원소까지 위의 과정을 반복하여 정렬을 완료 

### 병합 정렬

- 나누는 과정과 합치는 과정으로 이루어져 있음
    - 실제로 정렬이 이뤄 지는 시점은 2개의 리스트를 합병하는 단계

![병합정렬.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/79fc6158-622f-41df-b4d6-d39b49b45424/7238092b-9e3a-49b0-b3a9-3be1fc5eb69d/%E1%84%87%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%B8%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF.png)
![병합정렬](https://github.com/zzangzzangguy/CS-Study/assets/122965360/baa6c2ec-d364-446e-96d4-4bb558182c53)

![병합정렬2.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/79fc6158-622f-41df-b4d6-d39b49b45424/7b7a2284-3791-41d9-8898-d593f2172df1/%E1%84%87%E1%85%A7%E1%86%BC%E1%84%92%E1%85%A1%E1%86%B8%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF2.png)
![병합정렬2](https://github.com/zzangzzangguy/CS-Study/assets/122965360/3f04f26f-09c2-4381-9378-a0559463253b)

### 성능 분석

- 병합정렬은 추가적인 메모리를 필요로 한다

**시간 복잡도는 항상 O** 

- 배열을 반으로 분할하는 단계가 O(logn)
- 분할된 배열을 병합하는 단계가 O(n) 의 시간이 소요

### 동작 방식

1. 배열을 반으로 분할
2. 각 부분 배열에 대해 재귀적으로 병합 정렬을 수행
3. 분할된 부분 배열을 병합하여 정렬된 배열을 얻는다 

이중 가장 빠른 정렬은 **삽입정렬** 

- 미리 정렬되어있는 자료구조에서 가장 빠른성능을 가진다

### 왜?

→ 

- 버블정렬은 시간복잡도가 O(N^2) 이고
- 퀵, 머지소트는 분할-정복 과정을 거치기 때문에 느리다
- 이미 정렬된 부분의 올바른 위치에 삽입하는 방식으로 정렬하는 알고리즘
- 작은 규모의 배열에 대하여 효율적인 알고리즘 중 하나
- 시간복잡도는 최선의 경우 O(n), 최악의 경우 O(n^2)

### 삽입 정렬 - 동작 방식

### 중간

시간 복잡도에 대해 

시간 복잡도는 알고리즘의 실행 시간이 입력 크기에 어떻게 의존하는지를 나타내는 개념입니다. 알고리즘의 효율성을 평가하고 비교하는 데 사용됩니다. 일반적으로 알고리즘의 시간 복잡도는 입력 크기 n에 대한 함수로 나타내며, 대개 "빅 오 표기법"을 사용하여 표현됩니다.

빅 오 표기법은 알고리즘의 실행 시간을 상한선으로 표현하는 방식으로, 알고리즘의 성능을 최악의 경우에 대한 분석을 통해 평가합니다. 일반적으로 다음과 같은 빅 오 표기법이 사용됩니다:

1. **O(1): 상수 시간 복잡도.** 입력 크기에 관계없이 일정한 실행 시간을 가지는 알고리즘입니다. 예를 들어, 배열의 특정 요소를 찾는 것은 상수 시간이 소요됩니다.
2. **O(log n): 로그 시간 복잡도.** 입력 크기에 대해 로그 관계로 실행 시간이 증가하는 알고리즘입니다. 이진 검색과 같이 입력 크기를 반으로 나누어 검색하는 알고리즘은 일반적으로 로그 시간 복잡도를 가집니다.
3. **O(n): 선형 시간 복잡도.** 입력 크기에 비례하여 실행 시간이 증가하는 알고리즘입니다. 입력 배열을 한 번 순회하는 선형 검색은 선형 시간 복잡도를 가집니다.
4. **O(n log n): 선형 로그 시간 복잡도**. 일부 정렬 알고리즘 및 병합 정렬과 같은 분할 정복 알고리즘은 입력 크기에 대해 n*log(n) 시간이 걸립니다.
5. **O(n^2): 이차 시간 복잡도.** 두 개의 중첩된 반복문을 사용하여 입력 크기에 대해 제곱 관계로 실행 시간이 증가하는 알고리즘입니다. 삽입 정렬과 버블 정렬과 같은 일부 정렬 알고리즘이 이러한 복잡도를 가질 수 있습니다.
6. **O(2^n): 지수 시간 복잡도.** 입력 크기에 대해 지수적으로 실행 시간이 증가하는 알고리즘입니다. 하노이 탑과 같은 일부 재귀 알고리즘은 이러한 복잡도를 가집니다.
